<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>A Simple Hibernate, MySQL, and JUnit Tutorial</title>
        <meta name="viewport" content="width=device-width">
        <meta name="description" content="">
        <!-- Prism syntax highlighting -->
        <link href="https://codesolid.github.io/css/prism.css" rel="stylesheet" type="text/css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="https://codesolid.github.io/css/style.css">

        <!-- Navbar only -->
        <link rel="stylesheet" href="https://codesolid.github.io/css/nav.css">


    </head>

    <body>
        <div class="container">
        <nav id="nav">
        <ul>
        <li><a href="/index.html">Home</a></li>        
        <li><a href="/goalboost/">Goalboost.com</a></li>
        <li><a href="/hire/">Hire Us</a></li>
        <li><a href="/blog.html">Blog</a></li>
        <li><a href="/contact/">Contact Us</a></li>
        </ul>    
        </nav>

        <div class="site">        
          <h2>A Simple Hibernate, MySQL, and JUnit Tutorial</h2>
<p class="meta">22 May 2013</p>

<div class="post">
<h3>Contents</h3>

<ul>
<li><p>Getting Started with Hibernate and MySQL</p></li>
<li><p>Configuring MySQL</p></li>
<li><p>Configuring Hibernate</p></li>
<li><p>Minimizing Setup Time</p></li>
<li><p>A Simple Hibernate Entity</p></li>
<li><p>A Hibernate Generic Entity Storage Class</p></li>
<li><p>The JUnit Test</p></li>
</ul>

<h3>Getting Started With Hibernate and MySQL</h3>

<p>In this tutorial, we&#39;re once again going to use JUnit as a learning tool for exploring various Java technologies -- in this case Hibernate.  We&#39;ll be configuring Hibernate to run with MySQL in a way that works both in a standalone application or in a Spring or other web application.  Along the way we&#39;ll also be setting up Log4J logging for hibernate.  We&#39;ll work on a small generics class that -- although it doesn&#39;t really do much more than wrap a few Hibernate functions -- will allow us to demonstrate and test out the basic CRUD operations -- Create, Read, Update, and Delete.</p>

<p>As usual, you can download the complete project files for IntelliJ Idea from our <a href="https://github.com/CodeSolid/tutorials">Tutorials Repository on Github</a>. This tutorial is located in the HibernateGeneric directory.  If you&#39;re using Eclipse, check out our <a href="http://www.particlewave.com/2013/05/17/how-to-run-the-codesolid-tutorials-in-eclipse/">Eclipse instructions</a>.</p>

<h3>Configuring MySQL</h3>

<p>This tutorial assumes you have mysql installed and can log in as root.  If you don&#39;t have MySQL on your system, you should <a href="http://dev.mysql.com/doc/refman/5.1/en/windows-installation.html">start here</a> and work through the instructions appropriate to your environment.  Go into the mysql monitor (i.e., the mysql command line client).  To do this, run:</p>

<p><PathToMySQLBin>\mysql.exe --user=root --password=YourRootPassword</p>

<p>(If you haven&#39;t set a mysql root password, you should -- if you haven&#39;t, you can simply use the command:</p>

<p><PathToMySQLBin>\mysql.exe --user=root</p>

<p>Once you&#39;re connected in the mysql client, use the source command to run the dbsetup.sql script located in the database directory of the tutorial, for example:</p>

<p>source database\dbsetup.sql</p>

<p>[cc lang=&quot;SQL&quot;]
CREATE DATABASE tutorials;
USE tutorials;
GRANT ALL ON tutorials.* to &#39;myuser&#39;@&#39;localhost&#39; identified by &#39;mypassword&#39;;
commit;
flush privileges;
[/cc]</p>

<p>Of course, the user name and password given in this script are pretty brain-dead and certainly not secure so probably want to change them.  If you do, that&#39;s fine, you&#39;ll just need to make one other change, in the hibernate configuration file.  Let&#39;s look at that next:</p>

<h3>Configuring Hibernate</h3>

<p>The hibernate configuration file is the file hibernate.cfg.xml in the root of the resources directory (i.e., at src/main/resources).  As you can see, we&#39;ve configured the JDBC driver directly in this file.  If you changed the user name or password in the dbsetup.sql script, you need to make the corresponding chagnes to the &quot;connection.username&quot; and / or &quot;connection.password&quot; properties below.</p>

<p>You might also experiment with setting the show<em>sql and use</em>sql_comments to true, especially if you run into problems.  For now they are turned off to keep the test run output a little bit cleaner.</p>

<p>[cc lang=&quot;SQL&quot;]</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    com.mysql.jdbc.Driver
    jdbc:mysql://localhost/tutorials
    myuser
    mypassword


    1


    org.hibernate.dialect.MySQL5InnoDBDialect


    thread


    org.hibernate.cache.NoCacheProvider


    false
    false


    update
</code></pre></div>
<p>[/cc]
I won&#39;t post the log4j configuration here.  Hibernate issues a warning if logging is not enabled, so I have configured Hibernate to use the log file, &quot;log4j.log&quot; in the root of the project directory.  The configuration file for log4j is at src/main/resources/log4j.xml.</p>

<h3>Minimizing Setup Time</h3>

<p>As with any process that initially connects to a database, initializing Hibernate sessions takes a fair amount of time, and is not something you want to be doing over and over again in your tests.  In the case of Hibernate, creating the SessionFactory object takes even more time, adding up to about 1.4 seconds on a laptop, or about .8 seconds on a faster machine.  We don&#39;t want to be running that for every test class.  (To be sure, in the kind of one-class suite we&#39;re running in this tutorial, it wouldn&#39;t make a difference, but one of the purposes of these tutorials is to give you steal-able code that you can use in larger projects.  What we want is to initialize the SessionFactory only once.</p>

<p>The <a href="http://docs.jboss.org/hibernate/orm/3.3/reference/en-US/html/tutorial.html">Hibernate tutorial</a> that comes with the Hibernate docs gives us a part of the solution, the HibernateUtil class, which exists for the sole purpose of ensuring a one time initialization of a SessionFactory, which it then caches as a static object.  I&#39;ve used this class pretty much verbatim in the current tutorial, changing only the package name.</p>

<p>[cc lang=&quot;Java&quot;]
// This file is adapted with only minor changes from the original in the hibernate
// tutorial, http://docs.jboss.org/hibernate/orm/3.3/reference/en-US/html/tutorial.html.
package com.codesolid.tutorials.model.dal;</p>

<p>import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;</p>

<p>public class HibernateUtil {</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">private static final SessionFactory sessionFactory = buildSessionFactory();

private static SessionFactory buildSessionFactory() {
    try {
        // Create the SessionFactory from hibernate.cfg.xml
        return new Configuration().configure().buildSessionFactory();
    }
    catch (Throwable ex) {
        // Make sure you log the exception, as it might be swallowed
        System.err.println(&quot;Initial SessionFactory creation failed.&quot; + ex);
        throw new ExceptionInInitializerError(ex);
    }
}

public static SessionFactory getSessionFactory() {
    return sessionFactory;
}
</code></pre></div>
<p>}
[/cc]</p>

<p>OK, so we have a class where we can cache our SessionFactory, but the question remains -- how should we wire that up to our JUnit tests?  Since JUnit 4.9, we can use the @ClassRule annotation to set up a test suite with before and after methods that will run before and after all the classes in the suite have run.  This allows for the initialization of expensive resoures once before all the tests in the suite are run.</p>

<p>The following listing shows the RuleSuite test suite, which builds with the rest of the tests in the src\test\java\code\codesolid\tests directory:</p>

<p>[cc lang=&quot;Java&quot;]
package com.codesolid.tests;</p>

<p>import com.codesolid.tutorials.model.dal.HibernateUtil;
import org.apache.log4j.Level;
import org.apache.log4j.xml.Log4jEntityResolver;
import org.junit.ClassRule;
import org.junit.rules.ExternalResource;
import org.junit.runner.RunWith;
import org.junit.runners.Suite;
import org.apache.log4j.Logger;</p>

<p>@RunWith( Suite.class )
@Suite.SuiteClasses( {
        TestStorage.class
        /* , Add more test classes here separated by commas*/
} )
public class RuleSuite{</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">static HibernateUtil util;

// This is a static field.  Per the ClassRule documentation,
// to use a ClassRule we need a field that is &quot;public, static,
// and a subtype of of TestRule.&quot;
// See http://junit.czweb.org/apidocs/org/junit/ClassRule.html
@ClassRule
public static ExternalResource testRule = new ExternalResource(){
    @Override
    protected void before() throws Throwable{
        Logger.getLogger(&quot;com.codesolid.tests&quot;).log(Level.DEBUG, &quot;Inside RuleSuite::ExternalResource::before.&quot;);
        util = new HibernateUtil();
    };

    @Override
    protected void after(){
        // Nothing to do here in this case.
        Logger.getLogger(&quot;com.codesolid.tests&quot;).log(Level.DEBUG, &quot;Inside RuleSuite::ExternalResource::after.&quot;);
    };
};
</code></pre></div>
<p>}
[/cc]</p>

<p>I&#39;ve added some logging methods so you can see that the before and after methods are run only once at the start and end of the suite.</p>

<h3>A Simple Hibernate Entity</h3>

<p>In order to have an entity to save, I created an &quot;Actor&quot; entity.  This represents a user in the system, but I&#39;ve named the class &quot;Actor&quot; to avoid any potential conflict with the SQL keyword by the same name.  I am using Hibernate annotations to define the entity.</p>

<p>@Table allows us to name the table.
@Entity marks the class as representing a Hibernate Entity, that is to say, an object that Hibernate can save to and load from the database.</p>

<p>For the Id primary key field, we use the following Hibernate annotations to mark the field as the primary key and to auto-increment the field for each new record:</p>

<p>@Id
@GeneratedValue(generator=&quot;increment&quot;)
@GenericGenerator(name=&quot;increment&quot;, strategy = &quot;increment&quot;)</p>

<p>Finally, we used the column annotation to explicitly set the field name for the Role property to &quot;user_role&quot;:</p>

<p>@Column(name=&quot;user_role&quot;)</p>

<p>[cc lang=&quot;Java&quot;]
/**
 * Class Actor
 * Description:  A user of the system, the subject of a user story.  We use
 *               actor instead of user as table name to avoid any conflict
 *               with the database concept of user
 <em>/
package com.codesolid.tutorials.model.entities;
import org.hibernate.annotations.GenericGenerator;
import javax.persistence.</em>;</p>

<p>@Table( name = &quot;ACTORS&quot; )
@Entity
public class Actor {
    public static final String DEFAULT_ROLE = &quot;Standard User&quot;;</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">public Actor() {
    setRole(Actor.DEFAULT_ROLE);
}

private Long id;
private String role;

@Id
@GeneratedValue(generator=&quot;increment&quot;)
@GenericGenerator(name=&quot;increment&quot;, strategy = &quot;increment&quot;)
public Long getId() {
    return id;
}

public void setId(Long id) {
    this.id = id;
}


@Column(name=&quot;user_role&quot;)
public String getRole() {
    return role;
}

public void setRole(String role) {
    this.role = role;
}
</code></pre></div>
<p>}
[/cc]</p>

<p>The final step to making the Entity work is one that&#39;s easy to forget, but as we saw when we discussed the hibernate.cfg.xml file, make sure you include a mapping to the entity class, as we show again below:</p>

<p>[cc lang=&quot;XML&quot;]</p>

<p>[/cc]</p>

<h3>A Hibernate Generic Entity Storage Class</h3>

<p>While working with Hibernate enitities,  it struck me that many of the basic operations one might do with an entity could be captured well in a generic class, which is what we&#39;ll be using to test here. As you can see below, each of the methods was pretty much a wrapper around a single Hibernate session call -- with the exception of BeginTransaction, which combines getting the session from the session factory and starting the transaction.  </p>

<p>[cc lang=&quot;Java&quot;]
package com.codesolid.tutorials.model.dal;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;</p>

<p>public class Storage  {</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">public static SessionFactory getSessionFactory() {
    return HibernateUtil.getSessionFactory();
}

private T entity;
private Session session;

public void beginTransaction() {
    session = Storage.getSessionFactory().getCurrentSession();
    session.beginTransaction();
}

public void commit () {
    session.getTransaction().commit();
}

public Storage(T entity) {
    this.entity = entity;
}

public void update(T entity) {
    session.update(entity);
}

public Long insert(T entity) {
    return (Long) session.save(entity);
}

public void delete(T entity) {
    session.delete(entity);
}

// This call will issue a warning about the unchecked cast,
// but we know the value returned will be of the right type because
// we specify the entity (T) class in the call.
//
// Note that &quot;get&quot; will return a null if no value with this id fails
@SuppressWarnings (value=&quot;unchecked&quot;)
public T getById(Long id) {
    return (T) session.get(entity.getClass(), id);        
}
</code></pre></div>
<p>}
[/cc]
Taken together, this class and the unit tests I wrote for it were a good way to discover a couple of interesting Hibernate gotchas.  The first Hibernate mine that I steped on was that objects are no longer usable outside the context of a transaction.  Before my testing uncovered this, my original implementation of getById was called loadById, and the implementation and test looked something like this:</p>

<p>[cc lang=&quot;Java&quot;]
  // Implementation<br>
    public T getById(Long id) {
        storage.beginTransaction();
        T obj = (T) session.load(entity.getClass(), id);
        session.getTransaction().commit();
        return obj;
    }</p>

<p>// Test code:
   // ...
   Actor actor  = storage.getById(id);
   assertEquals(actor.getRole(), &quot;Some Role&quot;);
[/cc]</p>

<p>This seemed like a safe approach (albeit not an efficient one since each call is wrapped in a transaction).  As it turns out, because Hibernate uses lazy initialization, the object returned from getById needed to still have the transaction active.  As a result, I got the following exception:</p>

<p>org.hibernate.LazyInitializationException: could not initialize proxy - no Session</p>

<p>This caused me to push the transaction management out to the client, so I exposed beginTransaction and commit methods on my storage class.</p>

<p>At that point, the code and test looked like:</p>

<p>[cc lang=&quot;Java&quot;]
// Implmentation
public T getById(Long id) {
    return (T) session.load(entity.getClass(), id);
}</p>

<p>// Test code
storage.beginTransaction();
Actor actor  = storage.getById(id);
assertEquals(actor.getRole(), &quot;Some Role&quot;);
storage.commit();
[/cc]</p>

<p>The second interesting Hibernate quirk that I ran into was in trying to test my delete method.  Originally I wrote the test by deleting an object and then checking for the ObjectNotFoundException when I called loadById in an effort to reload the deleted object.  The first time I ran it, that test passed, but a few minutes later it failed.  It turns out that loadById may or may not return an ObjectNotFoundException, or it may instead return a &quot;proxy object&quot;, though I admit I have a bit of a hard time following the architectural genius behind the decision to return a proxy to an object that doesn&#39;t exist yet -- or in this case, doesn&#39;t exist any more.  At that time I researched it and found that getById has the more reasonable behavior of reliably returning a for objects that don&#39;t exist, so the test and the code evolved accordingly.</p>

<h3>The JUnit Test</h3>

<p>With that, the final form of the JUnit test is below.  Even though I&#39;m showing it last, in reality the process was more test-first, going back and forth between the tests, the configuration, and the classes under development.</p>

<p>[cc lang=&quot;Java&quot;]
package com.codesolid.tests;</p>

<p>import com.codesolid.tutorials.model.entities.<em>;
import com.codesolid.tutorials.model.dal.Storage;
import org.junit.Test;
import static org.junit.Assert.</em>;</p>

<p>public class TestStorage {</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">@Test
public void testWrite() {
    // Just a write, verify id set
    Actor user = new Actor();
    Storage storage = new Storage(user);
    storage.beginTransaction();
    user.setRole(&quot;SuperUser&quot;);
    assertNull(user.getId());
    storage.insert(user);
    assertNotNull(user.getId());
    storage.commit();
}

@Test
public void testWriteAndRead() {

    // This time write and read back
    String overRideRole = &quot;SuperUser&quot;;

    // Write
    Actor actor = new Actor();
    Storage storage = new Storage(actor);
    storage.beginTransaction();
    actor.setRole(overRideRole);
    assertNull(actor.getId());
    storage.insert(actor);
    assertNotNull(actor.getId());
    Long id = actor.getId();
    storage.commit();

    // Read and verify
    Actor actor2  = new Actor();
    assertEquals(actor2.getRole(), Actor.DEFAULT_ROLE);
    storage = new Storage(actor2);
    storage.beginTransaction();
    actor2 = storage.getById(id);
    assertEquals(actor2.getRole(), overRideRole);
    storage.commit();
}


@Test
public void testUpdate() {

    String overRideRole = &quot;SuperUser&quot;;
    String newOverrideRole = &quot;GUEST&quot;;

    // Insert an actor
    Actor actor = new Actor();
    Storage storage = new Storage(actor);
    storage.beginTransaction();
    actor.setRole(overRideRole);
    assertNull(actor.getId());
    storage.insert(actor);
    assertNotNull(actor.getId());
    Long id = actor.getId();
    storage.commit();

    // Read it back
    Actor actor2  = new Actor();
    assertEquals(actor2.getRole(), Actor.DEFAULT_ROLE);
    storage.beginTransaction();
    actor2 = storage.getById(id);
    assertEquals(actor2.getRole(), overRideRole);

    // Update it
    actor2.setRole(newOverrideRole);
    storage.update(actor2);
    storage.commit();

    // Read it again and verify update
    storage.beginTransaction();
    Actor actor3  = storage.getById(id);
    assertEquals(actor3.getRole(), newOverrideRole);
    storage.commit();
}

@Test
public void testDelete() {

    Actor actor = new Actor();
    Storage storage = new Storage(actor);

    // Write
    storage.beginTransaction();
    storage.insert(actor);
    Long id = actor.getId();
    storage.commit();

    // Delete it now
    assert(actor.getId() &gt; 0);
    storage.beginTransaction();
    storage.delete(actor);
    storage.commit();

    // Now we can&#39;t read it back, as expected
    storage.beginTransaction();
    Actor actor2 = storage.getById(id);
    assertNull(actor2);
    storage.commit();
}
</code></pre></div>
<p>}
[/cc]</p>

</div>

<!--
          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
              
            </div>
            <div class="contact">

              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
-->
          </div>

    <script src="/js/prism.js"></script>
    </div>
    </div>
    </body>
</html>
